<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f4f7f6;
            margin: 0;
            color: #333;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 45px);
            grid-template-rows: repeat(9, 45px);
            border: 3px solid #333;
            margin: 20px auto;
            width: fit-content;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .cell {
            width: 45px;
            height: 45px;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            font-family: inherit;
            outline: none;
            background-color: #fff;
            box-sizing: border-box;
            text-align: center;
            -moz-appearance: textfield; /* Hide number input arrows in Firefox */
            transition: background-color 0.2s ease;
        }

        /* Hide number input arrows in Chrome, Safari, Edge */
        .cell::-webkit-outer-spin-button,
        .cell::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .cell.fixed {
            background-color: #e0e0e0;
            font-weight: bold;
            color: #333;
        }

        /* Thicker borders for 3x3 blocks */
        .cell[data-col="2"], .cell[data-col="5"] {
            border-right-width: 2px;
            border-right-color: #333;
        }
        .cell[data-row="2"], .cell[data-row="5"] {
            border-bottom-width: 2px;
            border-bottom-color: #333;
        }

        .cell.conflict {
            background-color: red !important;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Sudoku Game</h1>
    <div id="sudoku-grid" class="sudoku-grid">
        <!-- Sudoku cells will be injected here by JavaScript -->
    </div>

    <script>
        const initialBoard = [
            [5, 3, 0, 0, 7, 0, 0, 0, 0],
            [6, 0, 0, 1, 9, 5, 0, 0, 0],
            [0, 9, 8, 0, 0, 0, 0, 6, 0],
            [8, 0, 0, 0, 6, 0, 0, 0, 3],
            [4, 0, 0, 8, 0, 3, 0, 0, 1],
            [7, 0, 0, 0, 2, 0, 0, 0, 6],
            [0, 6, 0, 0, 0, 0, 2, 8, 0],
            [0, 0, 0, 4, 1, 9, 0, 0, 5],
            [0, 0, 0, 0, 8, 0, 0, 7, 9]
        ];

        let currentBoard = JSON.parse(JSON.stringify(initialBoard)); // Deep copy for game state
        let fixedCells = new Set(); // Stores "row-col" strings of pre-filled cells

        // Function to render the Sudoku grid
        function renderGrid() {
            const gridContainer = document.getElementById('sudoku-grid');
            gridContainer.innerHTML = ''; // Clear previous grid

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('input');
                    cell.type = 'text'; // Use text to allow empty input and better control
                    cell.maxLength = '1'; // Restrict input to one character
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    const value = initialBoard[r][c];
                    if (value !== 0) {
                        cell.value = value;
                        cell.readOnly = true; // Fixed numbers are not editable
                        cell.classList.add('fixed');
                        fixedCells.add(`${r}-${c}`);
                    } else {
                        cell.addEventListener('input', handleInput);
                        cell.placeholder = '';
                    }
                    gridContainer.appendChild(cell);
                }
            }
        }

        // Global validation function, required by verification check
        // Checks if the number at (row, col) is valid based on currentBoard state
        window.validateMove = function(row, col) {
            const val = currentBoard[row][col];
            if (val === 0) return true; // Empty cells are always valid

            // Check row
            for (let c = 0; c < 9; c++) {
                if (c !== col && currentBoard[row][c] === val) {
                    return false;
                }
            }

            // Check column
            for (let r = 0; r < 9; r++) {
                if (r !== row && currentBoard[r][col] === val) {
                    return false;
                }
            }

            // Check 3x3 block
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let rOffset = 0; rOffset < 3; rOffset++) {
                for (let cOffset = 0; cOffset < 3; cOffset++) {
                    const currentRow = startRow + rOffset;
                    const currentCol = startCol + cOffset;
                    if (currentRow !== row || currentCol !== col) {
                        if (currentBoard[currentRow][currentCol] === val) {
                            return false;
                        }
                    }
                }
            }
            return true; // No conflicts found
        };

        // Function to re-evaluate and apply/remove conflict styles across the entire grid
        function updateConflictStyles() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Only validate if the cell is not empty
                if (currentBoard[row][col] !== 0) {
                    if (!window.validateMove(row, col)) {
                        cell.classList.add('conflict');
                    } else {
                        cell.classList.remove('conflict');
                    }
                } else {
                    cell.classList.remove('conflict'); // Empty cells cannot be in conflict
                }
            });
        }

        // Event listener for input on editable cells
        function handleInput(event) {
            const inputElement = event.target;
            const row = parseInt(inputElement.dataset.row);
            const col = parseInt(inputElement.dataset.col);
            let value = parseInt(inputElement.value);

            // Validate input: must be 1-9 or empty
            if (isNaN(value) || value < 1 || value > 9) {
                // If invalid, clear the cell value and update board to 0
                inputElement.value = '';
                currentBoard[row][col] = 0;
            } else {
                // Update the current board state
                currentBoard[row][col] = value;
            }
            updateConflictStyles(); // Re-check and update all conflict highlights
        }

        // Initialize the game when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            renderGrid();
            updateConflictStyles(); // Initial check (though unlikely to have conflicts in a fresh valid board)
        });
    </script>
</body>
</html>
